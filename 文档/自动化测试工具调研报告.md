# 自动化测试工具调研

## 基础知识

### 什么是自动化测试以及它的分类

自动化测试是指利用自动化工具执行测试用例、比较实际结果与预期结果、生成测试报告的过程。它能够减少人工干预，提高测试效率和准确性。

#### 按测试层次分类

1. **单元测试（Unit Testing）**
   - 测试最小可测试单元（通常是函数或方法）
   - 验证单个组件的功能正确性
   - 常用工具：Jest, Mocha

2. **集成测试（Integration Testing）**
   - 测试多个组件之间的交互
   - 验证模块间接口的正确性
   - 常用工具：Jest

3. **端到端测试（End-to-End Testing）**
   - 模拟真实用户场景的完整流程测试
   - 验证关键工作流程，运行部署前的冒烟测试
   - 常用工具：Cypress, Selenium, Playwright

#### 按测试类型分类

1. **功能测试**
   - 验证系统功能是否符合需求
   - 关注业务逻辑的正确性
   - 工具：Selenium, Cypress

2. **性能测试**
   - 测试系统在不同负载下的表现
   - 包括负载测试、压力测试、并发测试等
   - 工具：JMeter, K6, Artillery

3. **UI测试**
   - 验证界面元素的正确性
   - 测试页面布局和样式
   - 工具：Cypress, TestCafe

#### 按执行时机分类

1. **持续集成测试**
   - 在代码提交后自动触发
   - 快速发现集成问题
   - 与CI/CD流程紧密结合

2. **回归测试**
   - 验证新变更不影响现有功能
   - 定期或版本发布前执行
   - 确保系统稳定性

3. **冒烟测试**
   - 验证主要功能是否正常
   - 在构建完成后快速执行
   - 决定是否进行更深入测试

### 什么是自动化测试工具

自动化测试工具是一种软件测试工具，它能够自动执行预设的测试用例，模拟用户操作，并自动验证测试结果。这类工具可以帮助测试人员减少重复性工作，提高测试效率和准确性。

主要特点：
1. 自动化执行：能够按照预设的测试脚本自动运行测试
2. 可重复性：保证测试过程的一致性和可重复性
3. 效率提升：显著减少人工测试时间和成本
4. 结果可靠：降低人为错误，提供准确的测试结果

## 自动化测试工具功能

### 功能介绍

1. **测试执行**
   - 自动运行测试用例
   - 支持并行测试
   - 提供测试调度功能
   - 支持定时执行
2. **结果验证**
   - 自动比对实际结果和预期结果
   - 提供断言机制
   - 支持多种验证方式
3. **报告生成**
   - 自动生成测试报告
   - 提供详细的测试结果分析
   - 支持多种报告格式
   - 可视化测试数据
4. **环境管理**
   - 测试环境配置
   - 测试数据管理
   - 支持多环境切换

### 局限性

1. **初始投入成本高**
   - 前期脚本开发耗时较长
   - 工具学习成本较高

2. **维护成本**
   - 测试脚本需要持续维护
   - UI变更可能导致脚本失效
   - 需要定期更新测试数据

3. **测试覆盖限制**
   - 难以覆盖所有测试场景
   - 复杂业务流程自动化困难
   - 无法完全替代手工测试

4. **技术限制**
   - 特定场景可能无法自动化
   - 工具本身的局限性
   - 不同平台兼容性问题

## 成本与收益

| 收益 | 成本 |
|------|------|
| 测试的速度更快，范围更大，结论更可靠，并且可以替代相关的手动测试 | 首次适配项目的成本 |
| 对核心逻辑编写对应的测试，保证后续添加新需求时不会影响旧功能 | 新用例的编写成本 |
| | 后续改版对旧用例的破坏 |

收益大于成本的项目，引入自动化测试是值得的。

## 主流的自动化测试工具对比分析

### 单元测试框架对比

| 工具名称 | 特点 | 上手难度 | 接入成本 | 适用场景 |
|---------|------|---------|----------|----------|
| Jest | 1. 零配置开箱即用<br>2. 内置断言和Mock功能<br>3. 支持快照测试<br>4. 并行执行测试 | 低 | 低：<br>1. npm安装即可使用<br>2. 支持多种项目类型 | 1. 单元测试<br>2. 前端组件测试 |
| Mocha | 1. 灵活可扩展<br>2. 支持多种断言库<br>3. 支持异步测试<br>4. 丰富的插件生态 | 中 | 低：<br>1. npm安装简单<br>2. 需配置断言库 | 1. 单元测试<br>2. 集成测试<br>3. Node.js测试 |
| Vitest | 1. 兼容Jest API<br>2. Vite原生支持<br>3. 热更新测试 | 低 | 低：<br>1. Vite项目直接使用<br>2. 配置简单 | 1. 单元测试<br>2. 组件测试 |

Jest VS Vitest？相较于Jest，Vitest的配置更简单且速度更快，但是Vitest最低Node版本为18+，项目Node环境为12.18.0，不兼容，因此不选Vitest。

Jest VS Mocha？零配置、内置覆盖率 / 模拟 / 快照功能；适合 React/Vue 项目；社区活跃且学习成本低。Mocha通常用来测试Node.js后端项目。因此选择Jest。

因此推荐 Jest 作为单元测试框架。

### Vue 测试类库对比

| 工具名称 | 特点 | 上手难度 | 接入成本 | 适用场景 |
|---------|------|---------|----------|----------|
| @vue/test-utils | 1. Vue官方测试库<br>2. 支持Vue2/3<br>3. 组件挂载和交互<br>4. 丰富的API | 中 | 低：<br>1. npm直接安装<br>2. 配置简单 | 1. Vue组件测试<br>2. 单元测试 |
| Vue Testing Library | 1. 简单直观的API<br>2. 关注用户行为<br>3. 内置可访问性测试 | 低 | 低：<br>1. 易于集成<br>2. 配置简单 | 1. 组件测试<br>2. 集成测试 |

@vue/test-utils VS VTL？@vue/test-utils 更关注组件内部逻辑与状态管理，VTL 更关注组件的用户体验和行为。从测试用例的鲁棒性来看，后者是更好的选择。

### E2E测试框架对比

| 工具名称 | 特点 | 上手难度 | 接入成本 | 适用场景 |
|---------|------|---------|----------|----------|
| Cypress | 1. 实时重载和调试<br>2. 自动等待和重试机制 | 中 | 中：<br>1. 需要额外配置<br>2. 提供完整开发工具 | 1. E2E测试<br>2. UI自动化测试 |
| Playwright | 1. 支持多浏览器<br>2. 自动等待机制<br>3. 支持并行运行 | 中 | 低：<br>1. npm安装配置简单<br>2. 官方IDE插件支持 | 1. 跨浏览器测试<br>2. E2E测试 |
| Selenium | 1. 成熟稳定<br>2. 多语言支持<br>3. 广泛的社区支持<br>4. 跨平台兼容 | 高 | 高：<br>1. 需要配置WebDriver<br>2. 环境依赖较多 | 1. 传统Web测试<br>2. 跨浏览器测试<br>3. 复杂场景测试 |

Cypress VS Playwright？Playwright支持并行测试，多浏览器引擎。但是最低支持Node版本为14+，而项目环境为12.18.4。因此选择Cypress。

Cypress VS Selenium？Selenium接入成本较高，测试效率较Cypress低。因此选择Cypress。

因此推荐 Cypress 作为 E2E 测试框架。

## 接入自动化测试工具

### Cypress

#### 1. 接入项目

1. 安装 Cypress
```bash
npm install cypress@9.7.0 --save-dev
```
2. 初始化Cypress
```bash
npx cypress open
```
3. 添加测试脚本
```json
{
  "scripts": {
    "cy:open": "cypress open",
    "test:e2e": "cypress run"
  }
}
```
4. 配置 Cypress
```js
const { defineConfig } = require('cypress')

module.exports = defineConfig({
  viewportWidth: 1920,
  viewportHeight: 1080,
  video: false,
  screenshotOnRunFailure: true,
  experimentalSessionAndOrigin: true,
  experimentalStudio: true,
  e2e: {
    baseUrl: "",
  },
})
```

#### 2. 编写测试脚本

在`cypress/integration`目录下新建`index.spec.js`文件。
```js
describe('登录功能测试', () => {
    it('成功登录', () => {
        cy.visit('http://user.medmdt.net/user/index/login/');
        cy.get('.imgApp').click();
        cy.get('.form_username > .mp-input > .mp-input-con').clear();
        cy.get('.form_username > .mp-input > .mp-input-con').type(username);
        cy.get('.form_password > .mp-input > .mp-input-con').clear();
        cy.get('.form_password > .mp-input > .mp-input-con').type(password);
        cy.get('.check_img').click();
        cy.get('.mp-button').click();
        cy.url().should('eq', 'http://www.medmdt.net/?is_login=1&activeTK=isActive');
    });
});
```
也可以通过 Cypress Studio 进行录制，录制后会自动生成相关操作的代码。

#### 3. 执行测试

```bash
npm run test:e2e
```
或者
```bash
npm run cy:open
```
打开可视化页面进行测试。

#### 解决登录态不能共享的问题

原因：Cypress 默认情况下，每个测试用例都是独立运行的，这样做是为了确保测试的隔离性，避免相互影响。

解决方案：通过登录接口获取Cookies并设置为全局变量，在 beforeEach 获取变量并设置Cookies。

其他方案：
1. Cypress.Cookies.defaults,Cypress.Cookies.preserveOnce：这两个API可以防止Cookies被清除，但是在9.7.0版本中被弃用
2. Cypress.Session：这个API可以自动缓存 cookie，localstorage，但是只对set-cookie设置的cookie生效，与登录流程不符，因此不采用

```js
// cypress/support/commands.js
Cypress.Commands.add('login', (username, password) => {
    const sharedCookies = new Map();
    cy.request({
      method: 'POST',
      url: 'http://user.medmdt.net/user/index/doLogin',
      body: {
        userName: username,
        userPsw: password,
        num: 1
      }
    }).then((response) => {
      // 假设响应中包含cookie信息
      const cookies = response.headers['set-cookie'];
      const msg = response.body.msg;
      // 从msg中获取URL的query参数并添加到cookie
      if (msg) {
        const url = new URL(msg);
        const searchParams = new URLSearchParams(url.search);
        searchParams.forEach((value, key) => {
          if(key === 'pt') {
            const passport = parsePt(value);
            sharedCookies.set('loginName', username.toString());
            sharedCookies.set('token', encodeURIComponent(passport.token));
            sharedCookies.set('userID', passport.userID.toString());
            sharedCookies.set('realName', encodeURIComponent(passport.realName));
            sharedCookies.set('userName', passport.userName.toString());
            sharedCookies.set('userAvatar', passport.userAvatar.toString());
            sharedCookies.set('isCo', passport.isCo.toString());
            sharedCookies.set('isBeta', passport.isBeta.toString());

            function parsePt(str) {
              let s = str.replace('_', '/').split('.')[1];
              return JSON.parse(atob(s));
            }
          } else {
            sharedCookies.set(key, value);
          }
        });
      }
      // 设置cookie到测试环境
      if (cookies) {
        cookies.forEach(cookie => {
            const [name, value] = cookie.split('=');
            sharedCookies.set(name, value.split(';')[0]);
        });
      }
    });
    Cypress.env('sharedCookies', sharedCookies);
});

// **.spec.js
describe('Index组件测试', () => {
    before(() => {
      cy.login('', '');
    });

    beforeEach(() => {
      cy.viewport(1920, 1080);
      // 从sharedCookies中恢复所有cookie
      const sharedCookies = Cypress.env('sharedCookies');
      sharedCookies.forEach((value, key) => {
        cy.setCookie(key, value);
      });
    });
    
    it('应该正确渲染页面', () => {
      cy.visit('/');
      cy.get('.chat-box').should('exist');
      cy.get('.page').should('exist');
      cy.get('.chat-list').should('exist');
    });
});
```

### Jest

#### 1. 接入项目

1. 安装 Jest
```bash
npm install --save-dev jest@26 babel-jest@26 vue-jest@4
```
2. 添加测试脚本
```json
{
  "scripts": {
    "test:unit": "jest"
  }
}
```
3. 配置 Jest
```js
// jest.config.js
module.exports = {
  moduleFileExtensions: ['js', 'jsx', 'json', 'vue'],
  transform: {
    '^.+\.vue$': 'vue-jest',
    '^.+\.jsx?$': 'babel-jest'
  },
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1'
  },
  testMatch: [
    '**/tests/unit/**/*.spec.(js|jsx|ts|tsx)|**/__tests__/*.(js|jsx|ts|tsx)'
  ],
  testEnvironment: 'jsdom',
  testURL: '',
  collectCoverage: false,
  collectCoverageFrom: [
    'src/**/*.{js,vue}',
    '!src/main.js',
    '!**/node_modules/**'
  ]
}

// babel.config.js
module.exports = {
  presets: [
    ['@babel/preset-env', { targets: { node: 'current' } }]
  ],
  env: {
    test: {
      presets: [
        ['@babel/preset-env', { targets: { node: 'current' } }]
      ]
    }
  }
}
```

#### 2. 编写测试脚本

在`tests/unit`目录下创建`example.spec.js`文件
```js
import { shallowMount } from '@vue/test-utils'
import CommonSwitch from '@/component/CommonSwitch.vue'

describe('CommonSwitch.vue', () => {
  // 测试基本渲染
  it('正确渲染组件', () => {
    const wrapper = shallowMount(CommonSwitch)
    expect(wrapper.classes()).toContain('public-switch')
  })

  // 测试默认props
  it('使用默认props正确渲染', () => {
    const wrapper = shallowMount(CommonSwitch)
    expect(wrapper.props('value')).toBe(true)
    expect(wrapper.props('activeColor')).toBe('#0052D9')
    expect(wrapper.props('inactiveColor')).toBe('#C5C5C5')
  })

  // 测试自定义props
  it('使用自定义props正确渲染', () => {
    const wrapper = shallowMount(CommonSwitch, {
      propsData: {
        value: false,
        activeColor: '#000000',
        inactiveColor: '#FFFFFF'
      }
    })
    expect(wrapper.props('value')).toBe(false)
    expect(wrapper.props('activeColor')).toBe('#000000')
    expect(wrapper.props('inactiveColor')).toBe('#FFFFFF')
  })

  // 测试点击事件和状态切换
  it('点击时正确触发事件和切换状态', async () => {
    const wrapper = shallowMount(CommonSwitch)
    await wrapper.trigger('click')
    
    // 验证事件触发
    expect(wrapper.emitted('input')).toBeTruthy()
    expect(wrapper.emitted('input')[0]).toEqual([false])
    expect(wrapper.emitted('change')).toBeTruthy()
    expect(wrapper.emitted('change')[0]).toEqual([false])
  })

  // 测试watch value变化
  it('当value prop变化时更新内部状态', async () => {
    const wrapper = shallowMount(CommonSwitch, {
      propsData: {
        value: true
      }
    })
    
    await wrapper.setProps({ value: false })
    expect(wrapper.vm.val).toBe(false)
  })
})
```

#### 3. 执行测试

```bash
npm run test:unit
```

## 调研结论

经过对主流自动化测试工具的全面调研和分析，得出以下结论：

1. **技术选型建议**
   - 单元测试框架：采用 Jest 和 Vue Testing Library
     - 开箱即用，配置简单
     - 内置断言和Mock功能
     - 与项目Node版本(12.18.0)兼容
   
   - E2E测试框架：采用 Cypress 9.7.0
     - 安装配置简单
     - 提供可视化操作界面
     - 支持测试用例录制
     - 调试功能强大
     - 与项目技术栈匹配度高

2. **风险提示**
   - 需要合理评估初期投入成本
   - 测试脚本需要持续维护
   - UI变更可能导致用例失效
   - 部分复杂场景可能难以自动化

3. **预期收益**
   - 提高测试效率和覆盖率
   - 降低回归测试成本
   - 提前发现潜在问题
   - 保障代码质量
